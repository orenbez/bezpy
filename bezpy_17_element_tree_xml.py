import xml.etree.ElementTree as ET  # Deprecated since version 3.3: The xml.etree.cElementTree module
from xml.etree.ElementTree import Comment, tostring
import sys
from datetime import datetime as dt
### WARNING: do not name file xml.py

##############################################################################################################
### JSON vs XML Comparison
##############################################################################################################    
# JSON is data-oriented. XML is document-oriented. JSON is less secured than XML.
# JSON is faster and generally preferred as the structure is simpler and resembles a python dictionary
##############################################################################################################

# based on https://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree/


# XML takes a tree structure, each element other than the root element has one parent and one or more children

#=======================================================================================================================
# <tagname key1='val1 key2='val2'>text value</tagname>
#=======================================================================================================================
# tag = tagname as string
# attrib = attributes of tag -  as dictionary {'key1':'val1','key2':'val2'},  can use get(key1) for specific attribute
# text = text values of tag -  as string (for empty returns '\n    ')
#=======================================================================================================================

#=======================================================================================================================
# READ XML
#=======================================================================================================================
tree = ET.ElementTree(file='.\\mydata\\doc_in.xml')  # I think same as ET.parse('..xml')
root = tree.getroot()
# access root tagname and attributes directly
print(root.tag, root.attrib)
print(root.get('rootattr'))

# prints data on child, ONLY 1 level down
# Note: 2nd child tag essentialy has a next line char
for child in root:
    print (child.tag, child.attrib, child.text)


# access a specific child, by index:
print(root[0].tag, root[0].attrib, root[0].text)
print(root[1][0].text) # text of first subtag on 2nd branch



x = tree.find('tag') # finds the first tag - one level down

# search one level down only to findall of tags named 'tag'
for elem in tree.findall('tag'):
    print(elem.tag, elem.attrib, elem.text)

# loops through entire tree
for elem in tree.iter():
    print(elem.tag, elem.attrib, elem.text)

# loops through specific tags in full tree and finds one called <subtag>
for elem in tree.iter(tag='subtag'):
    print(elem.tag, elem.attrib, elem.text)

# search for specific XPATH branch/subbranch finds same tag <subtag>
# WARNING: this can not start from root,   root/tag/subtag, must start from first branch off the root.
for elem in tree.iterfind('tag/subtag'):
    print(elem.tag, elem.attrib, elem.text)


# Search for specific tagname and attribute and finds one <tag name1='attr_B'>Value</tag> ...
for elem in tree.iterfind('tag[@name1="attr_B"]'):
    print(elem.tag, elem.attrib, elem.text)




#=======================================================================================================================
# MODIFY XML
#=======================================================================================================================
# delete 2nd branch from root
del root[1]

# adds an attribute name and attribute value to first branch
root[0].set('foo', 'bar')

# sets value
root[1].text = 'value2'

# save xml data 
tree.write('.\\mydata\\tmp.xml')

#=======================================================================================================================
# CREATE XML 
#=======================================================================================================================
dtstamp = dt.strftime(dt.now(), '%M-%D-%Y %H:%M:%S')
root = ET.Element('root')
# inserts commment below <root> tag
root.append(Comment(f'Generated by xmlpractice.py on {dtstamp}'))

# set main branches from the root
branch1 = ET.Element('tag1')
branch2 = ET.Element('tag2')
root.append(branch1)
root.append(branch2)
# root.extend((branch1, branch2)) same as the two appends above


# Set lower level branch
child1 = ET.Element('subtag')
branch1.append(child1)

# Alternate method to set lower level branch
child2 = ET.SubElement(branch1, 'subtag')
child3 = ET.SubElement(branch2, 'subtag')

child2.set('name1', 'attr1')
child2.text = 'value'




tree = ET.ElementTree(root)

# display to screen
print (ET.tostring(root).decode())

# save xml file with DECLARATION, default encoding is 'us-ascii'
tree.write('.\\mydata\\doc_out.xml',encoding='utf-8', xml_declaration=True)


#=======================================================================================================================
# Don't bother with xml.dom or xml.sax stick to ElementTree
#=======================================================================================================================
# data.xml
# <data>
#     <items>
#         <item id="one">xxx</item>
#         <item id="two">yyy</item>
#         <item id="three">zzz</item>
#     </items>
# </data>
#
# many options for xml.   'ElementTree' is most preferred and in standard library
#

##from xml.dom import minidom
##xmldoc = minidom.parse('myfiles/data.xml')
##items = xmldoc.getElementsByTagName('item')
##print('Number Of Items:', len(items))
##for tag in items:
##    print(tag.tagName,tag.attributes['id'].value,tag.childNodes.item(0).data)
##print('2nd Item Id:', items[1].attributes['id'].value)
##print('2nd Item data:', items[1].childNodes.item(0).data)

#=======================================================================================================================










